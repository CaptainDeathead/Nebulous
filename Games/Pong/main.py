import pygame as pg

from Console.Controllers.controller import Controller, CONTROLS

from random import random, randint, uniform, choice
from math import sin, cos, radians, sqrt

from typing import List, Tuple, Sequence

print("""

PONGPONGPONG    PONGPONGPONGPONG    PONGPONG        PONG    PONGPONGPONGPONG
PONGPONGPONG    PONGPONGPONGPONG    PONGPONG        PONG    PONGPONGPONGPONG
PONG    PONG    PONG        PONG    PONGPONGPONG    PONG    PONG
PONG    PONG    PONG        PONG    PONG    PONG    PONG    PONG
PONGPONGPONG    PONG        PONG    PONG    PONG    PONG    PONG    PONGPONG
PONGPONGPONG    PONG        PONG    PONG        PONGPONG    PONG    PONGPONG
PONG            PONG        PONG    PONG        PONGPONG    PONG        PONG
PONG            PONG        PONG    PONG        PONGPONG    PONG        PONG
PONG            PONGPONGPONGPONG    PONG            PONG    PONGPONGPONGPONG
PONG            PONGPONGPONGPONG    PONG            PONG    PONGPONGPONGPONG


Created by CaptainDeathead.
Color generation functions generated by ChatGPT (All ChatGPT generated functions marked with '# <3 ChatGPT' above).
""")

FONTS_PATH = "./UI/Fonts"

# <3 ChatGPT
def hsv_to_rgb(h, s, v):
    h = h % 1.0
    i = int(h * 6)
    f = h * 6 - i
    p = int(255 * v * (1 - s))
    q = int(255 * v * (1 - f * s))
    t = int(255 * v * (1 - (1 - f) * s))
    v = int(255 * v)
    i = i % 6
    if i == 0: return (v, t, p)
    if i == 1: return (q, v, p)
    if i == 2: return (p, v, t)
    if i == 3: return (p, q, v)
    if i == 4: return (t, p, v)
    if i == 5: return (v, p, q)

# <3 ChatGPT
def generate_hue_contrasted_colors(threshold: float):
    # Threshold is from 0 to 1, maps to 0–180° hue separation (0–0.5 in HSV)
    min_hue_diff = threshold * 0.5  # because hue range is [0, 1]

    h1 = random()
    while True:
        h2 = random()
        hue_diff = abs(h2 - h1)
        hue_diff = min(hue_diff, 1.0 - hue_diff)  # wrap around
        if hue_diff >= min_hue_diff:
            break

    color1 = hsv_to_rgb(h1, 1.0, 1.0)
    color2 = hsv_to_rgb(h2, 1.0, 1.0)
    return color1, color2

class AXIS:
    X = 0
    Y = 1

class Paddle(pg.Rect):
    TOLERANCE = 0

    def __init__(self, x: int, y: int, width: int, height: int, surface: pg.Surface, axis: int, color: pg.Color, controller: Controller) -> None:
        super().__init__(x, y, width, height)

        self.surface = surface

        self.axis = axis
        self.color = color

        self.bg_color = (0, 0, 0)

        self.controller = controller

        self.speed = 500

        self.last_pos = (self.x, self.y)

    def reset(self) -> None:
        if self.axis == AXIS.X:
            self.x = self.surface.width // 2 - self.w // 2
        else:
            self.y = self.surface.height // 2 - self.h // 2

    def set_color(self, color: pg.Color) -> None:
        self.color = color

    def set_theme(self, bg_color: pg.Color, fg_color: pg.Color) -> None:
        self.bg_color = bg_color
        self.set_color(fg_color)

    def move_left(self, dt: float) -> None:
        self.move_ip(-self.speed * dt, 0)
        self.x = max(0, self.x)

    def move_right(self, dt: float) -> None:
        self.move_ip(self.speed * dt, 0)
        self.x = min(self.surface.width - self.w, self.x)

    def move_up(self, dt: float) -> None:
        self.move_ip(0, -self.speed * dt)
        self.y = max(0, self.y)

    def move_down(self, dt: float) -> None:
        self.move_ip(0, self.speed * dt)
        self.y = min(self.surface.height - self.h, self.y)

    def ai_move(self, bx: int, by: int, dt: float) -> None:
        if self.axis == AXIS.X:
            if self.x + self.width // 2 - self.TOLERANCE < bx:
                self.move_right(dt)
            elif self.x + self.width // 2 + self.TOLERANCE > bx:
                self.move_left(dt)
        else:
            if self.y + self.height // 2 - self.TOLERANCE < by:
                self.move_down(dt)
            elif self.y + self.height // 2 + self.TOLERANCE > by:
                self.move_up(dt)

    def draw(self) -> None:
        last_rect = (self.last_pos[0], self.last_pos[1], self.w, self.h)
        pg.draw.rect(self.surface, self.bg_color, last_rect)
        pg.display.update(last_rect)

        pg.draw.rect(self.surface, self.color, self)
        pg.display.update(self)

    def update(self, dt: int) -> None:
        for event in self.controller.event.get():
            if event.type == CONTROLS.DPAD.UP:
                if self.axis == AXIS.Y: self.move_up(dt)
            elif event.type == CONTROLS.DPAD.DOWN:
                if self.axis == AXIS.Y: self.move_down(dt)
            elif event.type == CONTROLS.DPAD.LEFT:
                if self.axis == AXIS.Y: self.move_left(dt)
            elif event.type == CONTROLS.DPAD.RIGHT:
                if self.axis == AXIS.Y: self.move_right(dt)

        self.draw()

        self.last_pos = (self.x, self.y)

class Pong:
    PYGAME_INFO: any = pg.display.Info()
    WIDTH: int = PYGAME_INFO.current_w
    HEIGHT: int = PYGAME_INFO.current_h

    VPADDLE_WIDTH = 20 * (WIDTH / 1920)
    VPADDLE_HEIGHT = 200 * (HEIGHT / 1080) * (HEIGHT / WIDTH)
    HPADDLE_WIDTH = 200 * (WIDTH / 1920) * (WIDTH / HEIGHT)
    HPADDLE_HEIGHT = 20 * (HEIGHT / 1080)

    BALL_RADIUS = 6

    COLOR_VISIBILITY_THRESHOLD = 0.95

    def __init__(self, display_surf: pg.Surface, console_update: object, get_num_players: object, controllers: List[Controller]) -> None:
        self.display_surf = display_surf
        self.console_update = console_update
        self.get_num_players = get_num_players
        self.controllers = controllers

        self.clock = pg.time.Clock()

        self.num_players = self.get_num_players()

        self.paddle_1 = Paddle(self.WIDTH - self.VPADDLE_WIDTH, self.HEIGHT // 2 - self.VPADDLE_HEIGHT // 2,
                               self.VPADDLE_WIDTH, self.VPADDLE_HEIGHT, self.display_surf, AXIS.Y, (255, 255, 255), self.controllers[0])
        self.paddle_2 = Paddle(0, self.HEIGHT // 2 - self.VPADDLE_HEIGHT // 2,
                               self.VPADDLE_WIDTH, self.VPADDLE_HEIGHT, self.display_surf, AXIS.Y, (255, 255, 255), self.controllers[1])
        self.paddle_3 = Paddle(self.WIDTH // 2 - self.HPADDLE_WIDTH // 2, 0, self.HPADDLE_WIDTH, self.HPADDLE_HEIGHT,
                               self.display_surf, AXIS.X, (255, 255, 255), self.controllers[2])
        self.paddle_4 = Paddle(self.WIDTH // 2 -self.HPADDLE_WIDTH // 2, self.HEIGHT - self.HPADDLE_HEIGHT, self.HPADDLE_WIDTH, self.HPADDLE_HEIGHT,
                               self.display_surf, AXIS.X, (255, 255, 255), self.controllers[3])

        self.paddles = (self.paddle_1, self.paddle_2, self.paddle_3, self.paddle_4)

        self.reset_ball()

        self.fg_color = (255, 255, 255)
        self.bg_color = (0, 0, 0)

        #self.controllers[0].plugged_in = True
        #self.controllers[1].plugged_in = True
        #self.controllers[2].plugged_in = True
        #self.controllers[3].plugged_in = True

        self.main()
    
    def luminance(self, color: Tuple[int]) -> float:
        return 0.2126 * color[0] + 0.7152 * color[1] + 0.0722 * color[2]

    def color_distance(self, color1: Tuple[int], color2: Tuple[int]) -> float:
        return sqrt(sum((a - b) ** 2 for a, b in zip(color1, color2))) / 441.67

    def gen_theme(self) -> Sequence[pg.Color]:
        self.bg_color, self.fg_color = generate_hue_contrasted_colors(0.8)

        return (self.bg_color, self.fg_color)

    def set_theme(self, background_color: pg.Color, foreground_color: pg.Color) -> None:
        for paddle in self.paddles:
            paddle.set_theme(background_color, foreground_color)

        self.fg_color = foreground_color
        self.bg_color = background_color

        self.display_surf.fill(self.bg_color)
        pg.display.flip()

    def reset_ball(self) -> None:
        self.ball_speed = 500

        self.ball_rect = pg.Rect(self.WIDTH // 2, self.HEIGHT // 2, self.BALL_RADIUS * 2, self.BALL_RADIUS * 2)

        direction = radians(choice([randint(45-30, 45+30), randint(135-30, 135+30), randint(225-30, 225+30), randint(315-30, 315+30)]))
        self.ball_vel = [cos(direction) * self.ball_speed, sin(direction) * self.ball_speed]

    def reset_paddles(self) -> None:
        for paddle in self.paddles:
            paddle.reset()

    def move_ball(self, dt: float) -> None:
        num_players = self.get_num_players()

        if num_players == 0: num_players = 4

        dt_count = int(dt // (1 / 60))
        dt_remain = dt - (dt_count / 60)

        if dt_count == 0:
            dt_remain = dt

        for i in range(dt_count):
            self.ball_rect.move_ip(self.ball_vel[0] * (1 / 60), self.ball_vel[1] * (1 / 60))

        self.ball_rect.move_ip(self.ball_vel[0] * dt_remain, self.ball_vel[1] * dt_remain)

        collision = False

        if self.paddle_1.colliderect(self.ball_rect) or self.paddle_2.colliderect(self.ball_rect):
            collision = True
            self.ball_vel[0] *= -1

            self.ball_vel[0] *= 1.1
            self.ball_vel[1] *= 1.1

        elif (num_players >= 3 and self.paddle_3.colliderect(self.ball_rect)) or (num_players >= 4 and self.paddle_4.colliderect(self.ball_rect)):
            collision = True
            self.ball_vel[1] *= -1
            
            self.ball_vel[0] *= 1.1
            self.ball_vel[1] *= 1.1

        if self.ball_rect.x <= 0 or self.ball_rect.x >= self.WIDTH:
            collision = True
            self.reset_ball()
            self.reset_paddles()

        elif (num_players >= 3 and self.ball_rect.y <= 0) or (num_players >= 4 and self.ball_rect.y >= self.HEIGHT):
            collision = True
            self.reset_ball()
            self.reset_paddles()
        
        else:
            if self.ball_rect.x <= 0 or self.ball_rect.x >= self.WIDTH:
                self.ball_vel[0] *= -1
            elif self.ball_rect.y <= 0 or self.ball_rect.y >= self.HEIGHT:
                self.ball_vel[1] *= -1

        if collision:
            bg, fg = self.gen_theme()
            self.set_theme(bg, fg)

    def main(self) -> None:
        while 1:
            dt = self.clock.tick(60) / 1000.0

            for event in pg.event.get():
                if event.type == pg.QUIT:
                    return

            self.console_update()

            num_players = self.get_num_players()

            match num_players:
                case 0:
                    for paddle in self.paddles:
                        paddle.ai_move(self.ball_rect.x, self.ball_rect.y, dt)
                case 1:
                    self.paddle_2.ai_move(self.ball_rect.x, self.ball_rect.y, dt)

            for i, paddle in enumerate(self.paddles):
                if num_players == 0:
                    paddle.update(dt)
                elif i < max(2, self.get_num_players()):
                    paddle.update(dt)
            
            screen_ball_rect = (self.ball_rect.x - self.ball_rect.w // 2, self.ball_rect.y - self.ball_rect.h // 2, self.ball_rect.w, self.ball_rect.h)
            pg.draw.rect(self.display_surf, self.bg_color, screen_ball_rect)
            pg.display.update(screen_ball_rect)

            self.move_ball(dt)

            screen_ball_rect = (self.ball_rect.x - self.ball_rect.w // 2, self.ball_rect.y - self.ball_rect.h // 2, self.ball_rect.w, self.ball_rect.h)
            pg.draw.rect(self.display_surf, self.fg_color, screen_ball_rect)
            pg.display.update(screen_ball_rect)